/**
 * OpenPackage Build Script
 * Generates openpackage.yml manifests for all plugins from marketplace.json metadata
 * 
 * This enables distribution via:
 *   opkg install gh@esimplicityinc/prima-delivery
 *   opkg install gh@esimplicityinc/prima-delivery --plugins debugging-toolkit
 */

import { readFile, writeFile, mkdir, access, readdir, stat } from 'fs/promises';
import { join, basename, dirname } from 'path';
import { stringify as yamlStringify } from 'yaml';

interface PluginMetadata {
  name: string;
  source: string;
  description: string;
  version: string;
  author: { name: string; url?: string; email?: string };
  homepage?: string;
  repository?: string;
  license: string;
  keywords?: string[];
  category?: string;
  commands?: string[];
  agents?: string[];
  skills?: string[];
}

interface MarketplaceJson {
  name: string;
  owner: { name: string; email: string; url?: string };
  metadata: { description: string; version: string };
  plugins: PluginMetadata[];
}

interface OpenPackageManifest {
  name: string;
  version: string;
  description: string;
  author: string;
  license: string;
  homepage?: string;
  repository?: string;
  keywords?: string[];
  category?: string;
  packages?: string[];
  'dev-packages'?: string[];
}

/**
 * Checks if a directory exists
 */
async function dirExists(path: string): Promise<boolean> {
  try {
    const stats = await stat(path);
    return stats.isDirectory();
  } catch {
    return false;
  }
}

/**
 * Gets subdirectories that exist in a plugin directory
 */
async function getPluginSubdirs(pluginPath: string): Promise<string[]> {
  const subdirs: string[] = [];
  const possibleDirs = ['agents', 'commands', 'skills', 'rules', 'root'];
  
  for (const dir of possibleDirs) {
    if (await dirExists(join(pluginPath, dir))) {
      subdirs.push(dir);
    }
  }
  
  return subdirs;
}

/**
 * Generates an openpackage.yml manifest for a single plugin
 */
function generatePluginManifest(plugin: PluginMetadata): OpenPackageManifest {
  const authorStr = plugin.author.email 
    ? `${plugin.author.name} <${plugin.author.email}>`
    : plugin.author.name;

  const manifest: OpenPackageManifest = {
    name: plugin.name,
    version: plugin.version,
    description: plugin.description,
    author: authorStr,
    license: plugin.license,
  };

  if (plugin.homepage) manifest.homepage = plugin.homepage;
  if (plugin.repository) manifest.repository = plugin.repository;
  if (plugin.keywords && plugin.keywords.length > 0) manifest.keywords = plugin.keywords;
  if (plugin.category) manifest.category = plugin.category;

  return manifest;
}

/**
 * Writes an openpackage.yml file with proper YAML formatting
 */
async function writeManifest(path: string, manifest: OpenPackageManifest): Promise<void> {
  const header = `# OpenPackage Manifest
# Auto-generated by scripts/build-openpackage.ts
# https://openpackage.dev/docs/packages

`;
  const yamlContent = yamlStringify(manifest, {
    lineWidth: 0, // Don't wrap lines
    defaultKeyType: 'PLAIN',
    defaultStringType: 'QUOTE_DOUBLE',
  });
  
  // Clean up the YAML - remove unnecessary quotes from simple strings
  const cleanedYaml = yamlContent
    .replace(/^"([a-zA-Z0-9_-]+)":/gm, '$1:')  // Remove quotes from keys
    .replace(/: "([^"\n]+)"$/gm, ': $1');      // Remove quotes from simple values
  
  await writeFile(path, header + cleanedYaml);
}

/**
 * Main build function
 */
async function buildOpenPackageManifests(): Promise<void> {
  console.log('OpenPackage Manifest Generator\n');
  console.log('Reading marketplace.json...');
  
  // Read marketplace.json
  const marketplacePath = '.claude-plugin/marketplace.json';
  const marketplaceContent = await readFile(marketplacePath, 'utf-8');
  const marketplace: MarketplaceJson = JSON.parse(marketplaceContent);
  
  console.log(`Found ${marketplace.plugins.length} plugins\n`);
  
  // Track statistics
  let generated = 0;
  let skipped = 0;
  let errors = 0;
  
  // Generate manifest for each plugin
  for (const plugin of marketplace.plugins) {
    const pluginDir = plugin.source.replace('./', '');
    const manifestPath = join(pluginDir, 'openpackage.yml');
    
    // Check if plugin directory exists
    if (!(await dirExists(pluginDir))) {
      console.log(`  [SKIP] ${plugin.name} - directory not found: ${pluginDir}`);
      skipped++;
      continue;
    }
    
    try {
      // Get existing subdirectories
      const subdirs = await getPluginSubdirs(pluginDir);
      
      // Generate and write manifest
      const manifest = generatePluginManifest(plugin);
      await writeManifest(manifestPath, manifest);
      
      console.log(`  [OK] ${plugin.name} (${subdirs.join(', ') || 'empty'})`);
      generated++;
    } catch (error) {
      console.log(`  [ERR] ${plugin.name}: ${error}`);
      errors++;
    }
  }
  
  // Summary
  console.log('\n' + '─'.repeat(50));
  console.log('Summary:');
  console.log(`  Generated: ${generated}`);
  console.log(`  Skipped:   ${skipped}`);
  console.log(`  Errors:    ${errors}`);
  console.log('─'.repeat(50));
  
  // Update root manifest version to match marketplace
  console.log('\nUpdating root openpackage.yml version...');
  const rootManifestPath = 'openpackage.yml';
  const rootContent = await readFile(rootManifestPath, 'utf-8');
  const updatedRoot = rootContent.replace(
    /^version:\s*.+$/m,
    `version: ${marketplace.metadata.version}`
  );
  await writeFile(rootManifestPath, updatedRoot);
  console.log(`  Root version set to ${marketplace.metadata.version}`);
}

/**
 * Generates a summary of all plugins for documentation
 */
async function generatePluginSummary(): Promise<void> {
  console.log('\nGenerating plugin summary...');
  
  const marketplacePath = '.claude-plugin/marketplace.json';
  const marketplaceContent = await readFile(marketplacePath, 'utf-8');
  const marketplace: MarketplaceJson = JSON.parse(marketplaceContent);
  
  // Group plugins by category
  const categories: Record<string, PluginMetadata[]> = {};
  for (const plugin of marketplace.plugins) {
    const category = plugin.category || 'uncategorized';
    if (!categories[category]) categories[category] = [];
    categories[category].push(plugin);
  }
  
  // Generate markdown table
  let summary = `# Prima Delivery Plugins

> Auto-generated plugin list for OpenPackage installation

## Quick Install

\`\`\`bash
# Install all plugins
opkg install gh@esimplicityinc/prima-delivery

# Install specific plugins
opkg install gh@esimplicityinc/prima-delivery --plugins <plugin-name>
\`\`\`

## Available Plugins (${marketplace.plugins.length})

`;

  for (const [category, plugins] of Object.entries(categories).sort()) {
    summary += `### ${category.charAt(0).toUpperCase() + category.slice(1)} (${plugins.length})\n\n`;
    summary += '| Plugin | Description | Version |\n';
    summary += '|--------|-------------|--------|\n';
    
    for (const plugin of plugins.sort((a, b) => a.name.localeCompare(b.name))) {
      summary += `| \`${plugin.name}\` | ${plugin.description.substring(0, 80)}${plugin.description.length > 80 ? '...' : ''} | ${plugin.version} |\n`;
    }
    summary += '\n';
  }
  
  await writeFile('PLUGINS.md', summary);
  console.log('  Generated PLUGINS.md');
}

// Main execution
async function main() {
  console.log('╔════════════════════════════════════════════╗');
  console.log('║   OpenPackage Build Pipeline               ║');
  console.log('╚════════════════════════════════════════════╝\n');
  
  const startTime = Date.now();
  
  try {
    await buildOpenPackageManifests();
    await generatePluginSummary();
    
    const duration = ((Date.now() - startTime) / 1000).toFixed(2);
    console.log(`\nCompleted in ${duration}s`);
    
    console.log('\nNext steps:');
    console.log('  1. Review generated openpackage.yml files in plugins/*/');
    console.log('  2. Test with: opkg install . --plugins debugging-toolkit');
    console.log('  3. Commit changes to enable: opkg install gh@esimplicityinc/prima-delivery');
    
  } catch (error) {
    console.error('Build failed:', error);
    process.exit(1);
  }
}

main();
